
Project
I/P: Working source code
O/P: Semantically equal obfuscated code


Identifier in Java program may denote
    • a package
    • a top-level type (either a class or an interface)
    • a nested type (either a class or an interface)
    • a field
    • a method
    • a parameter (of a method, a constructor, or an exception handler)
    • a local variable

Parameter and local variable are not available in the jvm compiled bytecode.



package name
    - inbuilt package
    - user defined package

class name:
    - implements or extends
        - user defined interface or class
        - inbuilt interface or class

Method name:
    - user defined
    - inbuilt (@override)

Variables:
    - no cases

Constants:
    - base64 encoding and corresponding method addition
    - encryption and decrpytion




methods


Identifiers that cannot be obfuscated:
    Exception group 1:
    The instance method that implements an abstract method of a superclass (or a superinterface) that is outside the obfuscation scope.

    Exception group 2:
    The instance method that overrides an inherited method of a superclass that is outside the obfuscation scope.

    Exception group 3:
    The instance method that serves as a callback function




/*********************************************************************************************************************/

    public static HashMap<String,IdentifierDependency> getDependencyData(String jsonStructurePath){

        /*
        *
        *   Algorithm:
        *   Step 1: Parses the json file and gets the list of java class files
        *   Step 2: Dependency data is stored as HashMap<String,IdentifierDependency>
                    key="Frag1.java"  value="HashMap<String,ArrayList<String>> hm"
                                               |->  key="file name in the project"  value="List of lines where Frag1.java occurs"
        *   Step 3: Call the renameAllFiles Method to populate the dependency data for each file and renames the classes
        *   Step 4: Use the printDependencyDataOfIdentifier function to print the dependency data of all the identifiers
        *
        * */

        // get the list of class files
        ArrayList<FileSystem> fsTemp=parseFileStructureJson(jsonStructurePath);
        ArrayList<String> classList=new ArrayList<>();
        getFilesList(fsTemp,classList);

        // Initialisation of dependency data
        HashMap<String, IdentifierDependency> dependencyData=new HashMap<>();
        for(String i:classList){
            File f=new File(i);
            dependencyData.put(f.getName(),new IdentifierDependency(f.getName()));
        }

        // parsing the project to get the dependency data
        fileOperations.renameAllFiles(classList,Constants.projectRootDirectory + Constants.packageName,dependencyData);

        // printing the dependency data for each identifier
        for(String i:classList){
            File f=new File(i);
            printDependencyDataOfIdentifier(f.getName(),dependencyData);
        }

        return dependencyData;
    }

    public static void printDependencyDataOfIdentifier(String identifierName, HashMap<String, IdentifierDependency> dependencyData){

        HashMap<String,ArrayList<String>> data=dependencyData.get(identifierName).getEntries();

        System.out.println("Dependencies of "+identifierName);
        for(String i:data.keySet()){
            ArrayList<String> lines=data.get(i);
            for(String j:lines)
                System.out.println("   "+j);
        }
    }


  public static void renameFile(ArrayList<String> classList,String filePath,HashMap<String,IdentifierDependency> dependencyData){

        File f;
        for(String i:classList){
            f=new File(i);
            IdentifierDependency id=dependencyData.get(f.getName());
            List<String> result = Unix4j.cat(filePath).grep(Grep.Options.n,f.getName().substring(0,f.getName().lastIndexOf("."))).toStringList();
            HashMap<String,ArrayList<String>> fileDependency=id.getEntries();
            fileDependency.put(filePath,new ArrayList<>(result));
            id.setEntries(fileDependency);
            dependencyData.put(f.getName(),id);
        }
    }


    public static void renameAllFiles(ArrayList<String> classList, String BackUpProjectPath,HashMap<String,IdentifierDependency> dependencyData){

        File folder = new File(BackUpProjectPath);
        File[] files = folder.listFiles();

        for (File file : files) {
            if (file.isFile()) {
                if(file.getName().charAt(0)!='.'){
                    //System.out.println(file.getAbsolutePath());
                    renameFile(classList,file.getAbsolutePath(),dependencyData);
                }

            }
            else if (file.isDirectory()) {
                System.out.println(file.getName());
                renameAllFiles(classList,file.getAbsolutePath(),dependencyData);
                //list(file.getAbsolutePath(),le);
            }
        }
    }


/***************************************************************************************************************************************/

Note: Method to check if a given word is a KeyWord:
    -> import javax.lang.model.SourceVersion;
    -> SourceVersion.isKeyword("void");

/***************************************************************************************************************************************/

    Method Renaming of android project

     /*
        *   O.P: Renames all the method name except overridden methods of inbuilt android classes and class constructors
        *   Algorithm:
        *   1. parse all the class file and build the regular expression containing all the method name to be
        *
        *   Cases to handle:
        *   1. Renaming the method in the declaration
        *   2. A user defined class overrides another user defined class which means the method renamed in parent class must also be renamed in the
        *      child class.
        *   3. Renaming the method when it is invoked by the corresponding object. We must not rename the method if it is not renamed in the definition
        *      of the class
        *
        *      e.g: btn1.performClick() -> here performClick must not be renamed as it is a method of the parent class
        *           => We must determine the class of the variable. If the class belongs to an inbuilt android class or belongs to an external library
        *              do not rename it else rename it
        *
        *   Cases not handled:
        *   1. if the method defined by the custom class is same as that of override method of a android SDK class
        *   2. did not check the cases encountered classes implements multiple interfaces
        *   3. What happens for mathods defined inside the 3rd party android library
        * */
